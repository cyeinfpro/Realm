{% extends "base.html" %}
{% block content %}
<div class="hero-card">
  <div class="hero-left">
    <span class="pill xs ghost">File Manager</span>
    <div class="hero-title">文件管理 · {{ site.name }}</div>
    <div class="hero-sub">根目录：<span class="mono">{{ root }}</span></div>
  </div>
  <div class="hero-right">
    <a class="btn sm ghost" href="/websites/{{ site.id }}">返回站点</a>
  </div>
</div>

{% if error %}
  <div class="flash" style="background:rgba(239,68,68,0.15);border-color:rgba(239,68,68,0.4);">
    {{ error }}
  </div>
{% endif %}

<div class="card" style="margin-top:12px;">
  <div class="row" style="justify-content:space-between;align-items:center;">
    <div class="col">
      <div class="file-path">
        {% for name, p in breadcrumbs %}
          <a href="/websites/{{ site.id }}/files?path={{ p }}">{{ name }}</a>
          {% if not loop.last %}<span class="sep">/</span>{% endif %}
        {% endfor %}
      </div>
      <div class="help">支持选择文件夹批量上传（含子目录）；单文件上限 200MB（分片 + 断点续传）。</div>
    </div>
    <div class="col right toolbar">
      <form method="post" action="/websites/{{ site.id }}/files/mkdir" style="display:inline;">
        <input type="hidden" name="path" value="{{ path }}">
        <input class="input" name="name" placeholder="新建目录">
        <button class="btn xs ghost" type="submit">创建</button>
      </form>
      <form id="uploadForm" method="post" action="/websites/{{ site.id }}/files/upload" enctype="multipart/form-data" style="display:inline;">
        <input type="hidden" name="path" value="{{ path }}">
        <input type="file" id="uploadFileInput" name="file" class="input">
        <input type="file" id="uploadFolderInput" name="folder" class="input" webkitdirectory directory multiple>
        <button class="btn xs secondary" type="submit" id="uploadBtn">上传</button>
      </form>
    </div>
  </div>

  <div id="uploadPanel" style="margin-top:10px;display:none;">
    <div class="progress"><div class="progress-fill" id="uploadProgressFill"></div></div>
    <div class="muted sm" id="uploadStatus" style="margin-top:6px;"></div>
    <button class="btn xs ghost" type="button" id="uploadRetry" style="margin-top:8px;display:none;">重试上传</button>
  </div>

  <div class="table-wrap" style="margin-top:12px;">
    <table class="table no-sticky">
      <thead>
        <tr>
          <th>名称</th>
          <th>大小</th>
          <th>修改时间</th>
          <th>操作</th>
        </tr>
      </thead>
      <tbody>
        {% for it in items %}
        <tr>
          <td>
            {% if it.is_dir %}
              <a href="/websites/{{ site.id }}/files?path={{ it.path }}" style="text-decoration:none;">目录 · {{ it.name }}</a>
            {% else %}
              {{ it.name }}
            {% endif %}
          </td>
          <td class="mono">{{ it.size_h }}</td>
          <td class="mono">{{ it.mtime or "-" }}</td>
          <td>
            {% if not it.is_dir %}
              <a class="btn xs ghost" href="/websites/{{ site.id }}/files/edit?path={{ it.path }}">编辑</a>
              <a class="btn xs ghost" href="/websites/{{ site.id }}/files/download?path={{ it.path }}">下载</a>
            {% endif %}
            <form method="post" action="/websites/{{ site.id }}/files/delete" style="display:inline;">
              <input type="hidden" name="path" value="{{ it.path }}">
              <button class="btn xs ghost" type="submit">删除</button>
            </form>
          </td>
        </tr>
        {% else %}
        <tr>
          <td colspan="4" class="muted">当前目录为空</td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>

<script>
const uploadForm = document.getElementById('uploadForm');
const uploadFileInput = document.getElementById('uploadFileInput');
const uploadFolderInput = document.getElementById('uploadFolderInput');
const uploadBtn = document.getElementById('uploadBtn');
const uploadPanel = document.getElementById('uploadPanel');
const uploadProgressFill = document.getElementById('uploadProgressFill');
const uploadStatus = document.getElementById('uploadStatus');
const uploadRetry = document.getElementById('uploadRetry');

const CHUNK_SIZE = 1024 * 512;
const SITE_ID = {{ site.id }};
const CUR_PATH = {{ path|tojson }};

function bytesToHuman(n){
  if(!n) return '0 B';
  const units = ['B','KB','MB','GB','TB'];
  let i = 0;
  let v = n;
  while(v >= 1024 && i < units.length - 1){
    v /= 1024;
    i++;
  }
  return v.toFixed(1) + ' ' + units[i];
}

function bufToHex(buffer){
  const bytes = new Uint8Array(buffer);
  const hex = [];
  for(const b of bytes){
    hex.push(b.toString(16).padStart(2, '0'));
  }
  return hex.join('');
}

async function sha256Hex(arrayBuffer){
  const hash = await crypto.subtle.digest('SHA-256', arrayBuffer);
  return bufToHex(hash);
}

async function chunkToBase64(arrayBuffer){
  let binary = '';
  const bytes = new Uint8Array(arrayBuffer);
  const len = bytes.byteLength;
  for(let i=0;i<len;i++){
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

function uploadKey(file, path, filename){
  const p = path || CUR_PATH || '';
  const f = filename || file.name || '';
  return `nexus_upload_${SITE_ID}_${p}_${f}_${file.size}_${file.lastModified}`;
}

async function getResumeOffset(file, uploadId, path, filename){
  const resp = await fetch(`/websites/${SITE_ID}/files/upload_status`, {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({ path: path || CUR_PATH, filename: filename || file.name, upload_id: uploadId })
  });
  const data = await resp.json().catch(()=>({ok:false}));
  if(!data.ok) return 0;
  return parseInt(data.offset || 0, 10) || 0;
}

function splitRelPath(rel){
  const clean = String(rel || '').replace(/^\\/+/, '').replace(/\\\\/g, '/');
  if(!clean) return {dir:'', name:''};
  const parts = clean.split('/').filter(Boolean);
  const name = parts.pop() || '';
  return {dir: parts.join('/'), name};
}

function joinPath(a,b){
  const aa = String(a || '').replace(/\\/+$/,'');
  const bb = String(b || '').replace(/^\\/+/, '');
  if(!aa) return bb;
  if(!bb) return aa;
  return aa + '/' + bb;
}

function resolveUploadTarget(file){
  const rel = file.webkitRelativePath || '';
  if(rel){
    const info = splitRelPath(rel);
    return {path: joinPath(CUR_PATH, info.dir), filename: info.name || file.name};
  }
  return {path: CUR_PATH, filename: file.name};
}

async function uploadFile(file, uploadId, startOffset, path, filename, totalBytes, baseUploaded){
  let offset = startOffset || 0;
  const total = file.size;
  uploadPanel.style.display = 'block';
  uploadRetry.style.display = 'none';
  uploadBtn.disabled = true;
  uploadStatus.textContent = `准备上传 ${file.name} (${bytesToHuman(total)})…`;
  if(total === 0){
    const resp = await fetch(`/websites/${SITE_ID}/files/upload_chunk`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        path: path || CUR_PATH,
        filename: filename || file.name,
        upload_id: uploadId,
        offset: 0,
        done: true,
        allow_empty: true
      })
    });
    const data = await resp.json().catch(()=>({ok:false,error:'上传失败'}));
    if(!data.ok){
      throw new Error(data.error || '上传失败');
    }
    const pct = totalBytes > 0 ? Math.min(100, Math.round(((baseUploaded + total) / totalBytes) * 100)) : 100;
    uploadProgressFill.style.width = pct + '%';
    uploadStatus.textContent = `已上传 ${bytesToHuman(baseUploaded + total)} / ${bytesToHuman(totalBytes)} (${pct}%)`;
    return;
  }
  while(offset < total){
    const chunk = file.slice(offset, offset + CHUNK_SIZE);
    const buf = await chunk.arrayBuffer();
    const chunkSha = await sha256Hex(buf);
    const b64 = await chunkToBase64(buf);
    const done = (offset + chunk.size) >= total;
    const resp = await fetch(`/websites/${SITE_ID}/files/upload_chunk`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        path: path || CUR_PATH,
        filename: filename || file.name,
        upload_id: uploadId,
        offset: offset,
        done: done,
        content_b64: b64,
        chunk_sha256: chunkSha
      })
    });
    const data = await resp.json().catch(()=>({ok:false,error:'上传失败'}));
    if(!data.ok){
      if(data.expected_offset !== undefined){
        offset = parseInt(data.expected_offset || 0, 10) || 0;
        continue;
      }
      throw new Error(data.error || '上传失败');
    }
    offset += chunk.size;
    const overall = baseUploaded + offset;
    const pct = totalBytes > 0 ? Math.min(100, Math.round((overall / totalBytes) * 100)) : 100;
    uploadProgressFill.style.width = pct + '%';
    uploadStatus.textContent = `已上传 ${bytesToHuman(overall)} / ${bytesToHuman(totalBytes)} (${pct}%)`;
    localStorage.setItem(uploadKey(file, path, filename), uploadId);
  }
  localStorage.removeItem(uploadKey(file, path, filename));
  uploadStatus.textContent = '上传完成';
  uploadBtn.disabled = false;
}

uploadForm?.addEventListener('submit', async (e)=>{
  if(!window.crypto || !window.crypto.subtle){
    return;
  }
  e.preventDefault();
  const folderFiles = uploadFolderInput?.files ? Array.from(uploadFolderInput.files) : [];
  const singleFile = uploadFileInput?.files?.[0];
  const files = folderFiles.length ? folderFiles : (singleFile ? [singleFile] : []);
  if(!files.length){
    alert('请选择文件或文件夹');
    return;
  }
  const totalBytes = files.reduce((s,f)=>s + (f.size || 0), 0) || 0;
  let uploadedBytes = 0;
  try{
    for(let i=0;i<files.length;i++){
      const file = files[i];
      const target = resolveUploadTarget(file);
      uploadStatus.textContent = `上传中：${i+1}/${files.length} · ${file.name}`;
      const key = uploadKey(file, target.path, target.filename);
      let uploadId = localStorage.getItem(key) || '';
      if(!uploadId){
        uploadId = Math.random().toString(16).slice(2) + Date.now().toString(16);
      }
      const offset = await getResumeOffset(file, uploadId, target.path, target.filename);
      uploadedBytes += offset;
      await uploadFile(file, uploadId, offset, target.path, target.filename, totalBytes, uploadedBytes - offset);
      uploadedBytes += (file.size - offset);
    }
    window.location.reload();
  }catch(err){
    uploadStatus.textContent = String(err);
    uploadRetry.style.display = 'inline-block';
  }
});

uploadRetry?.addEventListener('click', async ()=>{
  const folderFiles = uploadFolderInput?.files ? Array.from(uploadFolderInput.files) : [];
  const singleFile = uploadFileInput?.files?.[0];
  const files = folderFiles.length ? folderFiles : (singleFile ? [singleFile] : []);
  if(!files.length) return;
  const totalBytes = files.reduce((s,f)=>s + (f.size || 0), 0) || 0;
  let uploadedBytes = 0;
  try{
    for(let i=0;i<files.length;i++){
      const file = files[i];
      const target = resolveUploadTarget(file);
      uploadStatus.textContent = `上传中：${i+1}/${files.length} · ${file.name}`;
      const key = uploadKey(file, target.path, target.filename);
      const uploadId = localStorage.getItem(key) || '';
      if(!uploadId){
        uploadStatus.textContent = '找不到可恢复的上传';
        return;
      }
      const offset = await getResumeOffset(file, uploadId, target.path, target.filename);
      uploadedBytes += offset;
      await uploadFile(file, uploadId, offset, target.path, target.filename, totalBytes, uploadedBytes - offset);
      uploadedBytes += (file.size - offset);
    }
    window.location.reload();
  }catch(err){
    uploadStatus.textContent = String(err);
  }
});
</script>
{% endblock %}
